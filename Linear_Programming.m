%数据定义:
%...............................................................................................
%所需的数据查询：
%总价值：Obj; 前一步总时间Total_time;
%前一步总花费Total_cost；邻接矩阵A；景点数目：len-1；参观的景点是哪些：vertex；
%参观景点的归一化权重：norm_v；住宿天数：real_date; gain：视频收益
%最终的各个参观景点的时间安排：T；其内容对应这vertex数组的内容
%重构后的结果：参观时间安排T；总时间final_time; 总消耗:final_cost；路线; vertex或者A
%！！！！！！若是求解问题3，请放开105行注释，注意Lingo输出的.txt文件路径要和matlab读取的一致。
%...............................................................................................
%景点的价值，参观花费，参观时间，参观收益：
value = [0 0.1115 0.0607 0.0649 0.0485 0.0548 0.1019 0.0507 0.104 0.0562 0.088 0.1067 0.0663 0.0858];
v_cost = [0 150 100 200 100 100 100 100 100 150 100 150 100 150];
v_time = [0 4 4 4 4 4 4 4 4 4 4 4 4 4];
v_gain = [0 67.7 69 67.5 70.1 67.4 69.7 66.8 67.7 67.4 64.3 71.2 66.9 65.8];

%边的定义：两节点之间的路程花费和时间
e_time = [0.0 0.5 4.5 4.5 7.0 4.5 1.0 4.5 2.0 7.0 2.5 1.0 3.0 3.0
		  0.5 0.0 4.0 4.0 6.5 4.0 0.5 4.0 1.5 6.5 2.0 0.5 2.5 2.5
		  4.5 4.0 0.0 4.0 4.0 2.0 4.5 0.5 4.5 4.5 4.0 4.5 2.0 4.0
		  4.5 4.0 4.0 0.0 4.0 5.0 5.0 5.0 5.0 7.5 6.0 5.0 4.0 3.5
		  7.0 6.5 4.0 4.0 0.0 4.5 6.5 4.0 7.0 6.0 7.0 6.5 4.5 5.0
		  4.5 4.0 2.0 5.0 4.5 0.0 4.5 1.5 4.5 4.0 4.5 4.0 2.0 4.0
		  1.0 0.5 4.5 5.0 6.5 4.5 0.0 4.5 1.5 7.0 2.0 0.5 3.0 2.5
		  4.5 4.0 0.5 5.0 4.0 1.5 4.5 0.0 5.5 4.5 4.5 4.5 2.0 4.0
		  2.0 1.5 4.5 5.0 7.0 4.5 1.5 5.0 0.0 7.5 2.5 1.0 3.0 2.5
		  7.0 6.5 4.5 7.5 6.0 4.0 7.0 4.5 7.5 0.0 7.5 7.5 5.0 7.0
		  2.5 2.0 4.0 6.0 7.0 4.5 2.0 4.5 2.5 7.5 0.0 2.5 3.0 3.5
		  1.0 0.5 4.5 5.0 6.5 4.0 0.5 4.5 1.0 7.5 2.5 0.0 3.0 2.5
		  3.0 2.5 2.0 4.0 4.5 2.0 3.0 2.0 3.0 5.0 3.0 3.0 0.0 3.0
		  3.0 2.5 4.0 3.5 5.0 4.0 2.5 4.0 2.5 7.0 3.5 2.5 3.0 0.0];
      
e_cost = [0   5   133 185 244 133 15  133 15  185 35  15  94  93
		   5   0   128 180 239 128 10  128 10  180 30  10  89  98
		   128 128  0  208 144 10  128 10  128 156 160 128 50  146
		   185 180 208  0  54  208 180 208 180 378 239 180 160 106
		   244 239 144 54  0   144 239 144 239 104 285 239 170 176
		   133 128 10  208 144  0  128 10  128 156 160 128 50  146
		   15  10  128 180 239 128  0  128 10  180 30  10  89  98
		   133 128 10  208 144 10  128  0  239 104 285 239 170 176
		   15  10  128 180 239 128 10  239  0  180 30  10  89  98
		   185 180 156 378 104 156 180 104 180  0  318 180 203 203
		   35  30  160 239 285 160 30  285 30  318  0  30  122 102
		   15  10  128 180 239 128 10  239 10  180 30  0   89  98	
		   94  89  50  160 170 50  89  170 89  203 122 89  0   106
		   93  98  146 106 179 146 98  176 98  303 102 98 106   0];
  %常数项:节点数目，人数，固定住宿费用，总资金数目
  ver_num = 14;
  per_num = 1;
  rel_cost = 150;
  max_cost = 3000;
  %每个景点的推荐参观时间
  s_time = [0 4 8 8 8 4 4 4 8 8 4 4 4 8];
  %算法的第二部分，主要用来当时间和金钱都有富裕的时候，重构高优先级景点的游玩时间
  %Lingo计算出来的路径,指经过哪些节点
  A = zeros(ver_num,ver_num);
  %读取文本数据，按行填充
  data = load('D:\Allprojects\Matlab\math_mode\out.txt');
  road = data(:,3);
  %填充
  k = 1;
  for i = 1:ver_num
      for j = 1:ver_num
          A(i,j) = road(k);
          k = k+1;
      end
  end
  %目标函数值
  Obj = sum(value.*A,'all');
  %总时间
  Total_time = sum(e_time.*A,'all') + sum(v_time.*A,'all');
  %住宿天数,没有取模的结果，想一下怎么处理这个结果
  rel_date = Total_time/12;
  %总花费
  Total_cost = per_num*(sum(e_cost.*A, 'all') + sum(v_cost.*A,'all') + rel_date * rel_cost);
  %重构前不变的量：通勤时间和花费，景点花费
  fixed_time = sum(e_time.*A,'all');
  fixed_cost = per_num*(sum(e_cost.*A, 'all') + sum(v_cost.*A,'all'));
  %重构时间
  %更合理的重建方式是通过景点的重要性来重建:
  %选出前一步需要参观的景点，也就是除了起点外，入度为1的点
  %可见其第一个值必定为1，代表起点
  k=1;
  len = sum(A,'all');
  vertex = zeros(1,sum(A,'all'));
  for i = 1:ver_num
      temp = 0;
      for j = 1:ver_num
          temp = temp + A(j,i);
      end
      if temp == 1
          vertex(k) = i;
          k = k+1;
      end
  end
  %求所选的数组是哪些，共有多少个, 减去1代表景点数目
  norm_v = zeros(1,sum(A,'all'));
  gain = 0;
  %归一化权重
  for i = 1:len
      norm_v(i) = value(vertex(i))/Obj;
      gain = gain + v_gain(vertex(i));
  end
  %重新计算最大收益，因为有视频了:
%   max_cost = max_cost + gain;
  if (Total_time <= 120 && Total_cost <= max_cost-10)
      %求解另一个优化问题了
      disp("执行了CVX程序");
      cvx_begin
        variable T(1,len);
        expression fun_obj(1,len);
        for i = 1:len
            fun_obj(i) = norm_v(i)*T(i);
        end
        maximize (sum(fun_obj));
        subject to
            fixed_time + sum(T) <= 120;
            fixed_cost + per_num*rel_cost*(fixed_time + sum(T))/12 <= max_cost;
            for i = 2:len
                T(i) <= 12;
                T(i) >= 4;
            end
            %起点不需要时间
            T(1) == 0;
        cvx_end     
  end
  %最后的总时间和总花费
  if strcmp(cvx_status,'Solved')
      disp("执行了这个程序");
      final_time = sum(T)+fixed_time;
      final_cost = fixed_cost + per_num*rel_cost*final_time/12;
  else
      final_time = Total_time;
      final_cost = Total_cost;
  end
  %算法的第三部分：重构每天的时间安排，可选,人工重建吧
  